(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{525:function(t,e,n){"use strict";n.r(e);var a=n(28),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"react-常考进阶知识点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-常考进阶知识点"}},[t._v("#")]),t._v(" React 常考进阶知识点")]),t._v(" "),n("p",[t._v("这一章节我们将来学习 React 的一些经常考到的进阶知识点。")]),t._v(" "),n("h2",{attrs:{id:"hoc-是什么-相比-mixins-有什么优点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hoc-是什么-相比-mixins-有什么优点"}},[t._v("#")]),t._v(" HOC 是什么？相比 mixins 有什么优点？")]),t._v(" "),n("p",[t._v("很多人看到高阶组件（HOC）这个概念就被吓到了，认为这东西很难，其实这东西概念真的很简单，我们先来看一个例子。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function add(a, b) {\n    return a + b\n}\n\n")])])]),n("p",[t._v("现在如果我想给这个 "),n("code",[t._v("add")]),t._v(" 函数添加一个输出结果的功能，那么你可能会考虑我直接使用 "),n("code",[t._v("console.log")]),t._v(" 不就实现了么。说的没错，但是如果我们想做的更加优雅并且容易复用和扩展，我们可以这样去做：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function withLog (fn) {\n    function wrapper(a, b) {\n        const result = fn(a, b)\n        console.log(result)\n        return result\n    }\n    return wrapper\n}\nconst withLogAdd = withLog(add)\nwithLogAdd(1, 2)\n\n")])])]),n("p",[t._v("其实这个做法在函数式编程里称之为高阶函数，大家都知道 React 的思想中是存在函数式编程的，高阶组件和高阶函数就是同一个东西。我们实现一个函数，传入一个组件，然后在函数内部再实现一个函数去扩展传入的组件，最后返回一个新的组件，这就是高阶组件的概念，作用就是为了更好的复用代码。")]),t._v(" "),n("p",[t._v("其实 HOC 和 Vue 中的 mixins 作用是一致的，并且在早期 React 也是使用 mixins 的方式。但是在使用 class 的方式创建组件以后，mixins 的方式就不能使用了，并且其实 mixins 也是存在一些问题的，比如：")]),t._v(" "),n("ul",[n("li",[t._v("隐含了一些依赖，比如我在组件中写了某个 "),n("code",[t._v("state")]),t._v(" 并且在 "),n("code",[t._v("mixin")]),t._v(" 中使用了，就这存在了一个依赖关系。万一下次别人要移除它，就得去 "),n("code",[t._v("mixin")]),t._v(" 中查找依赖")]),t._v(" "),n("li",[t._v("多个 "),n("code",[t._v("mixin")]),t._v(" 中可能存在相同命名的函数，同时代码组件中也不能出现相同命名的函数，否则就是重写了，其实我一直觉得命名真的是一件麻烦事。。")]),t._v(" "),n("li",[t._v("雪球效应，虽然我一个组件还是使用着同一个 "),n("code",[t._v("mixin")]),t._v("，但是一个 "),n("code",[t._v("mixin")]),t._v(" 会被多个组件使用，可能会存在需求使得 "),n("code",[t._v("mixin")]),t._v(" 修改原本的函数或者新增更多的函数，这样可能就会产生一个维护成本")])]),t._v(" "),n("p",[t._v("HOC 解决了这些问题，并且它们达成的效果也是一致的，同时也更加的政治正确（毕竟更加函数式了）。")]),t._v(" "),n("h2",{attrs:{id:"事件机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事件机制"}},[t._v("#")]),t._v(" 事件机制")]),t._v(" "),n("p",[t._v("React 其实自己实现了一套事件机制，首先我们考虑一下以下代码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const Test = ({ list, handleClick }) => ({\n    list.map((item, index) => (\n        <span onClick={handleClick} key={index}>{index}</span>\n    ))\n})\n\n")])])]),n("p",[t._v("以上类似代码想必大家经常会写到，但是你是否考虑过点击事件是否绑定在了每一个标签上？事实当然不是，JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 "),n("code",[t._v("document")]),t._v(" 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。")]),t._v(" "),n("p",[t._v("另外冒泡到 "),n("code",[t._v("document")]),t._v(" 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 "),n("code",[t._v("event.stopPropagation")]),t._v(" 是无效的，而应该调用 "),n("code",[t._v("event.preventDefault")]),t._v("。")]),t._v(" "),n("p",[t._v("那么实现合成事件的目的是什么呢？总的来说在我看来好处有两点，分别是：")]),t._v(" "),n("ul",[n("li",[t._v("合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力")]),t._v(" "),n("li",[t._v("对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。")])])])}),[],!1,null,null,null);e.default=s.exports}}]);