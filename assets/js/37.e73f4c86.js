(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{520:function(v,e,_){"use strict";_.r(e);var t=_(28),n=Object(t.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"js-基础知识点及常考面试题-一"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#js-基础知识点及常考面试题-一"}},[v._v("#")]),v._v(" JS 基础知识点及常考面试题（一）")]),v._v(" "),_("p",[v._v("JS 对于每位前端开发都是必备技能，在小册中我们也会有多个章节去讲述这部分的知识。首先我们先来熟悉下 JS 的一些常考和容易混乱的基础知识点。")]),v._v(" "),_("h2",{attrs:{id:"原始-primitive-类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原始-primitive-类型"}},[v._v("#")]),v._v(" 原始（Primitive）类型")]),v._v(" "),_("blockquote",[_("p",[v._v("涉及面试题：原始类型有哪几种？null 是对象嘛？")])]),v._v(" "),_("p",[v._v("在 JS 中，存在着 6 种原始值，分别是：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("boolean")])]),v._v(" "),_("li",[_("code",[v._v("null")])]),v._v(" "),_("li",[_("code",[v._v("undefined")])]),v._v(" "),_("li",[_("code",[v._v("number")])]),v._v(" "),_("li",[_("code",[v._v("string")])]),v._v(" "),_("li",[_("code",[v._v("symbol")])])]),v._v(" "),_("p",[v._v("首先原始类型存储的都是值，是没有函数可以调用的，比如 "),_("code",[v._v("undefined.toString()")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/14/16711c4f991c73ac?w=526&h=53&f=png&s=10255",alt:""}})]),v._v(" "),_("p",[v._v("此时你肯定会有疑问，这不对呀，明明 "),_("code",[v._v("'1'.toString()")]),v._v(" 是可以使用的。其实在这种情况下，"),_("code",[v._v("'1'")]),v._v(" 已经不是原始类型了，而是被强制转换成了 "),_("code",[v._v("String")]),v._v(" 类型也就是对象类型，所以可以调用 "),_("code",[v._v("toString")]),v._v(" 函数。")]),v._v(" "),_("p",[v._v("除了会在必要的情况下强转类型以外，原始类型还有一些坑。")]),v._v(" "),_("p",[v._v("其中 JS 的 "),_("code",[v._v("number")]),v._v(" 类型是浮点类型的，在使用中会遇到某些 Bug，比如 "),_("code",[v._v("0.1 + 0.2 !== 0.3")]),v._v("，但是这一块的内容会在进阶部分讲到。"),_("code",[v._v("string")]),v._v(" 类型是不可变的，无论你在 "),_("code",[v._v("string")]),v._v(" 类型上调用何种方法，都不会对值有改变。")]),v._v(" "),_("p",[v._v("另外对于 "),_("code",[v._v("null")]),v._v(" 来说，很多人会认为他是个对象类型，其实这是错误的。虽然 "),_("code",[v._v("typeof null")]),v._v(" 会输出 "),_("code",[v._v("object")]),v._v("，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，"),_("code",[v._v("000")]),v._v(" 开头代表是对象，然而 "),_("code",[v._v("null")]),v._v(" 表示为全零，所以将它错误的判断为 "),_("code",[v._v("object")]),v._v(" 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。")]),v._v(" "),_("h2",{attrs:{id:"对象-object-类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象-object-类型"}},[v._v("#")]),v._v(" 对象（Object）类型")]),v._v(" "),_("blockquote",[_("p",[v._v("涉及面试题：对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？")])]),v._v(" "),_("p",[v._v("在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("const a = []\n\n")])])]),_("p",[v._v("对于常量 "),_("code",[v._v("a")]),v._v(" 来说，假设内存地址（指针）为 "),_("code",[v._v("#001")]),v._v("，那么在地址 "),_("code",[v._v("#001")]),v._v(" 的位置存放了值 "),_("code",[v._v("[]")]),v._v("，常量 "),_("code",[v._v("a")]),v._v(" 存放了地址（指针） "),_("code",[v._v("#001")]),v._v("，再看以下代码")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("const a = []\nconst b = a\nb.push(1)\n\n")])])]),_("p",[v._v("当我们将变量赋值给另外一个变量时，复制的是原本变量的地址（指针），也就是说当前变量 "),_("code",[v._v("b")]),v._v(" 存放的地址（指针）也是 "),_("code",[v._v("#001")]),v._v("，当我们进行数据修改的时候，就会修改存放在地址（指针） "),_("code",[v._v("#001")]),v._v(" 上的值，也就导致了两个变量的值都发生了改变。")]),v._v(" "),_("p",[v._v("接下来我们来看函数参数是对象的情况")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("function test(person) {\n  person.age = 26\n  person = {\n    name: 'yyy',\n    age: 30\n  }\n\n  return person\n}\nconst p1 = {\n  name: 'yck',\n  age: 25\n}\nconst p2 = test(p1)\nconsole.log(p1) // -> ?\nconsole.log(p2) // -> ?\n\n")])])]),_("p",[v._v("对于以上代码，你是否能正确的写出结果呢？接下来让我为你解析一番：")]),v._v(" "),_("ul",[_("li",[v._v("首先，函数传参是传递对象指针的副本")]),v._v(" "),_("li",[v._v("到函数内部修改参数的属性这步，我相信大家都知道，当前 "),_("code",[v._v("p1")]),v._v(" 的值也被修改了")]),v._v(" "),_("li",[v._v("但是当我们重新为 "),_("code",[v._v("person")]),v._v(" 分配了一个对象时就出现了分歧，请看下图")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/14/16712ce155afef8c?w=658&h=414&f=png&s=37772",alt:""}})]),v._v(" "),_("p",[v._v("所以最后 "),_("code",[v._v("person")]),v._v(" 拥有了一个新的地址（指针），也就和 "),_("code",[v._v("p1")]),v._v(" 没有任何关系了，导致了最终两个变量的值是不相同的。")]),v._v(" "),_("h2",{attrs:{id:"typeof-vs-instanceof"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#typeof-vs-instanceof"}},[v._v("#")]),v._v(" typeof vs instanceof")]),v._v(" "),_("blockquote",[_("p",[v._v("涉及面试题：typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？")])]),v._v(" "),_("p",[_("code",[v._v("typeof")]),v._v(" 对于原始类型来说，除了 "),_("code",[v._v("null")]),v._v(" 都可以显示正确的类型")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("typeof 1 // 'number'\ntypeof '1' // 'string'\ntypeof undefined // 'undefined'\ntypeof true // 'boolean'\ntypeof Symbol() // 'symbol'\n\n")])])]),_("p",[_("code",[v._v("typeof")]),v._v(" 对于对象来说，除了函数都会显示 "),_("code",[v._v("object")]),v._v("，所以说 "),_("code",[v._v("typeof")]),v._v(" 并不能准确判断变量到底是什么类型")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("typeof [] // 'object'\ntypeof {} // 'object'\ntypeof console.log // 'function'\n\n")])])]),_("p",[v._v("如果我们想判断一个对象的正确类型，这时候可以考虑使用 "),_("code",[v._v("instanceof")]),v._v("，因为内部机制是通过原型链来判断的，在后面的章节中我们也会自己去实现一个 "),_("code",[v._v("instanceof")]),v._v("。")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("const Person = function() {}\nconst p1 = new Person()\np1 instanceof Person // true\n\nvar str = 'hello world'\nstr instanceof String // false\n\nvar str1 = new String('hello world')\nstr1 instanceof String // true\n\n")])])]),_("p",[v._v("对于原始类型来说，你想直接通过 "),_("code",[v._v("instanceof")]),v._v(" 来判断类型是不行的，当然我们还是有办法让 "),_("code",[v._v("instanceof")]),v._v(" 判断原始类型的")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("class PrimitiveString {\n  static [Symbol.hasInstance](x) {\n    return typeof x === 'string'\n  }\n}\nconsole.log('hello world' instanceof PrimitiveString) // true\n\n")])])]),_("p",[v._v("你可能不知道 "),_("code",[v._v("Symbol.hasInstance")]),v._v(" 是什么东西，其实就是一个能让我们自定义 "),_("code",[v._v("instanceof")]),v._v(" 行为的东西，以上代码等同于 "),_("code",[v._v("typeof 'hello world' === 'string'")]),v._v("，所以结果自然是 "),_("code",[v._v("true")]),v._v(" 了。这其实也侧面反映了一个问题， "),_("code",[v._v("instanceof")]),v._v(" 也不是百分之百可信的。")]),v._v(" "),_("h2",{attrs:{id:"类型转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类型转换"}},[v._v("#")]),v._v(" 类型转换")]),v._v(" "),_("blockquote",[_("p",[v._v("涉及面试题：该知识点常在笔试题中见到，熟悉了转换规则就不惧怕此类题目了。")])]),v._v(" "),_("p",[v._v("首先我们要知道，在 JS 中类型转换只有三种情况，分别是：")]),v._v(" "),_("ul",[_("li",[v._v("转换为布尔值")]),v._v(" "),_("li",[v._v("转换为数字")]),v._v(" "),_("li",[v._v("转换为字符串")])]),v._v(" "),_("p",[v._v("我们先来看一个类型转换表格，然后再进入正题")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/15/16716dec14421e47?w=910&h=648&f=png&s=110463",alt:""}})]),v._v(" "),_("h3",{attrs:{id:"转boolean"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#转boolean"}},[v._v("#")]),v._v(" 转Boolean")]),v._v(" "),_("p",[v._v("在条件判断时，除了 "),_("code",[v._v("undefined")]),v._v("， "),_("code",[v._v("null")]),v._v("， "),_("code",[v._v("false")]),v._v("， "),_("code",[v._v("NaN")]),v._v("， "),_("code",[v._v("''")]),v._v("， "),_("code",[v._v("0")]),v._v("， "),_("code",[v._v("-0")]),v._v("，其他所有值都转为 "),_("code",[v._v("true")]),v._v("，包括所有对象。")]),v._v(" "),_("h3",{attrs:{id:"对象转原始类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象转原始类型"}},[v._v("#")]),v._v(" 对象转原始类型")]),v._v(" "),_("p",[v._v("对象在转换类型的时候，会调用内置的 "),_("code",[v._v("[[ToPrimitive]]")]),v._v(" 函数，对于该函数来说，算法逻辑一般来说如下：")]),v._v(" "),_("ul",[_("li",[v._v("如果已经是原始类型了，那就不需要转换了")]),v._v(" "),_("li",[v._v("调用 "),_("code",[v._v("x.valueOf()")]),v._v("，如果转换为基础类型，就返回转换的值")]),v._v(" "),_("li",[v._v("调用 "),_("code",[v._v("x.toString()")]),v._v("，如果转换为基础类型，就返回转换的值")]),v._v(" "),_("li",[v._v("如果都没有返回原始类型，就会报错")])]),v._v(" "),_("p",[v._v("当然你也可以重写 "),_("code",[v._v("Symbol.toPrimitive")]),v._v(" ，该方法在转原始类型时调用优先级最高。")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("let a = {\n  valueOf() {\n    return 0\n  },\n  toString() {\n    return '1'\n  },\n  [Symbol.toPrimitive]() {\n    return 2\n  }\n}\n1 + a // => 3\n\n")])])]),_("h3",{attrs:{id:"四则运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四则运算符"}},[v._v("#")]),v._v(" 四则运算符")]),v._v(" "),_("p",[v._v("加法运算符不同于其他几个运算符，它有以下几个特点：")]),v._v(" "),_("ul",[_("li",[v._v("运算中其中一方为字符串，那么就会把另一方也转换为字符串")]),v._v(" "),_("li",[v._v("如果一方不是字符串或者数字，那么会将它转换为数字或者字符串")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("1 + '1' // '11'\ntrue + true // 2\n4 + [1,2,3] // \"41,2,3\"\n\n")])])]),_("p",[v._v("如果你对于答案有疑问的话，请看解析：")]),v._v(" "),_("ul",[_("li",[v._v("对于第一行代码来说，触发特点一，所以将数字 "),_("code",[v._v("1")]),v._v(" 转换为字符串，得到结果 "),_("code",[v._v("'11'")])]),v._v(" "),_("li",[v._v("对于第二行代码来说，触发特点二，所以将 "),_("code",[v._v("true")]),v._v(" 转为数字 "),_("code",[v._v("1")])]),v._v(" "),_("li",[v._v("对于第三行代码来说，触发特点二，所以将数组通过 "),_("code",[v._v("toString")]),v._v(" 转为字符串 "),_("code",[v._v("1,2,3")]),v._v("，得到结果 "),_("code",[v._v("41,2,3")])])]),v._v(" "),_("p",[v._v("另外对于加法还需要注意这个表达式 "),_("code",[v._v("'a' + + 'b'")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("'a' + + 'b' // -> \"aNaN\"\n\n")])])]),_("p",[v._v("因为 "),_("code",[v._v("+ 'b'")]),v._v(" 等于 "),_("code",[v._v("NaN")]),v._v("，所以结果为 "),_("code",[v._v('"aNaN"')]),v._v("，你可能也会在一些代码中看到过 "),_("code",[v._v("+ '1'")]),v._v(" 的形式来快速获取 "),_("code",[v._v("number")]),v._v(" 类型。")]),v._v(" "),_("p",[v._v("那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("4 * '3' // 12\n4 * [] // 0\n4 * [1, 2] // NaN\n\n")])])]),_("h3",{attrs:{id:"比较运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#比较运算符"}},[v._v("#")]),v._v(" 比较运算符")]),v._v(" "),_("ol",[_("li",[v._v("如果是对象，就通过 "),_("code",[v._v("toPrimitive")]),v._v(" 转换对象")]),v._v(" "),_("li",[v._v("如果是字符串，就通过 "),_("code",[v._v("unicode")]),v._v(" 字符索引来比较")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("let a = {\n  valueOf() {\n    return 0\n  },\n  toString() {\n    return '1'\n  }\n}\na > -1 // true\n\n")])])]),_("p",[v._v("在以上代码中，因为 "),_("code",[v._v("a")]),v._v(" 是对象，所以会通过 "),_("code",[v._v("valueOf")]),v._v(" 转换为原始类型再比较值。")]),v._v(" "),_("h2",{attrs:{id:"this"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[v._v("#")]),v._v(" this")]),v._v(" "),_("blockquote",[_("p",[v._v("涉及面试题：如何正确判断 this？箭头函数的 this 是什么？")])]),v._v(" "),_("p",[_("code",[v._v("this")]),v._v(" 是很多人会混淆的概念，但是其实它一点都不难，只是网上很多文章把简单的东西说复杂了。在这一小节中，你一定会彻底明白 "),_("code",[v._v("this")]),v._v(" 这个概念的。")]),v._v(" "),_("p",[v._v("我们先来看几个函数调用的场景")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("function foo() {\n  console.log(this.a)\n}\nvar a = 1\nfoo()\n\nconst obj = {\n  a: 2,\n  foo: foo\n}\nobj.foo()\n\nconst c = new foo()\n\n")])])]),_("p",[v._v("接下来我们一个个分析上面几个场景")]),v._v(" "),_("ul",[_("li",[v._v("对于直接调用 "),_("code",[v._v("foo")]),v._v(" 来说，不管 "),_("code",[v._v("foo")]),v._v(" 函数被放在了什么地方，"),_("code",[v._v("this")]),v._v(" 一定是 "),_("code",[v._v("window")])]),v._v(" "),_("li",[v._v("对于 "),_("code",[v._v("obj.foo()")]),v._v(" 来说，我们只需要记住，谁调用了函数，谁就是 "),_("code",[v._v("this")]),v._v("，所以在这个场景下 "),_("code",[v._v("foo")]),v._v(" 函数中的 "),_("code",[v._v("this")]),v._v(" 就是 "),_("code",[v._v("obj")]),v._v(" 对象")]),v._v(" "),_("li",[v._v("对于 "),_("code",[v._v("new")]),v._v(" 的方式来说，"),_("code",[v._v("this")]),v._v(" 被永远绑定在了 "),_("code",[v._v("c")]),v._v(" 上面，不会被任何方式改变 "),_("code",[v._v("this")])])]),v._v(" "),_("p",[v._v("说完了以上几种情况，其实很多代码中的 "),_("code",[v._v("this")]),v._v(" 应该就没什么问题了，下面让我们看看箭头函数中的 "),_("code",[v._v("this")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("function a() {\n  return () => {\n    return () => {\n      console.log(this)\n    }\n  }\n}\nconsole.log(a()()())\n\n")])])]),_("p",[v._v("首先箭头函数其实是没有 "),_("code",[v._v("this")]),v._v(" 的，箭头函数中的 "),_("code",[v._v("this")]),v._v(" 只取决包裹箭头函数的第一个普通函数的 "),_("code",[v._v("this")]),v._v("。在这个例子中，因为包裹箭头函数的第一个普通函数是 "),_("code",[v._v("a")]),v._v("，所以此时的 "),_("code",[v._v("this")]),v._v(" 是 "),_("code",[v._v("window")]),v._v("。另外对箭头函数使用 "),_("code",[v._v("bind")]),v._v(" 这类函数是无效的。")]),v._v(" "),_("p",[v._v("最后种情况也就是 "),_("code",[v._v("bind")]),v._v(" 这些改变上下文的 API 了，对于这些函数来说，"),_("code",[v._v("this")]),v._v(" 取决于第一个参数，如果第一个参数为空，那么就是 "),_("code",[v._v("window")]),v._v("。")]),v._v(" "),_("p",[v._v("那么说到 "),_("code",[v._v("bind")]),v._v("，不知道大家是否考虑过，如果对一个函数进行多次 "),_("code",[v._v("bind")]),v._v("，那么上下文会是什么呢？")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("let a = {}\nlet fn = function () { console.log(this) }\nfn.bind().bind(a)() // => ?\n\n")])])]),_("p",[v._v("如果你认为输出结果是 "),_("code",[v._v("a")]),v._v("，那么你就错了，其实我们可以把上述代码转换成另一种形式")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("// fn.bind().bind(a) 等于\nlet fn2 = function fn1() {\n  return function() {\n    return fn.apply()\n  }.apply(a)\n}\nfn2()\n\n")])])]),_("p",[v._v("可以从上述代码中发现，不管我们给函数 "),_("code",[v._v("bind")]),v._v(" 几次，"),_("code",[v._v("fn")]),v._v(" 中的 "),_("code",[v._v("this")]),v._v(" 永远由第一次 "),_("code",[v._v("bind")]),v._v(" 决定，所以结果永远是 "),_("code",[v._v("window")]),v._v("。")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("let a = { name: 'yck' }\nfunction foo() {\n  console.log(this.name)\n}\nfoo.bind(a)() // => 'yck'\n\n")])])]),_("p",[v._v("以上就是 "),_("code",[v._v("this")]),v._v(" 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 "),_("code",[v._v("this")]),v._v(" 最终指向哪里。")]),v._v(" "),_("p",[v._v("首先，"),_("code",[v._v("new")]),v._v(" 的方式优先级最高，接下来是 "),_("code",[v._v("bind")]),v._v(" 这些函数，然后是 "),_("code",[v._v("obj.foo()")]),v._v(" 这种调用方式，最后是 "),_("code",[v._v("foo")]),v._v(" 这种调用方式，同时，箭头函数的 "),_("code",[v._v("this")]),v._v(" 一旦被绑定，就不会再被任何方式所改变。")]),v._v(" "),_("p",[v._v("如果你还是觉得有点绕，那么就看以下的这张流程图吧，图中的流程只针对于单个规则。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/15/16717eaf3383aae8?w=744&h=531&f=png&s=32062",alt:""}})])])}),[],!1,null,null,null);e.default=n.exports}}]);