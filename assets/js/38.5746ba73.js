(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{526:function(e,t,n){"use strict";n.r(t);var _=n(28),a=Object(_.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"js-基础知识点及常考面试题-二"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-基础知识点及常考面试题-二"}},[e._v("#")]),e._v(" JS 基础知识点及常考面试题（二）")]),e._v(" "),n("p",[e._v("在这一章节中我们继续来了解 JS 的一些常考和容易混乱的基础知识点。")]),e._v(" "),n("h2",{attrs:{id:"vs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vs"}},[e._v("#")]),e._v(" == vs ===")]),e._v(" "),n("blockquote",[n("p",[e._v("涉及面试题：== 和 === 有什么区别？")])]),e._v(" "),n("p",[e._v("对于 "),n("code",[e._v("==")]),e._v(" 来说，如果对比双方的类型"),n("strong",[e._v("不一样")]),e._v("的话，就会进行"),n("strong",[e._v("类型转换")]),e._v("，这也就用到了我们上一章节讲的内容。")]),e._v(" "),n("p",[e._v("假如我们需要对比 "),n("code",[e._v("x")]),e._v(" 和 "),n("code",[e._v("y")]),e._v(" 是否相同，就会进行如下判断流程：")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("首先会判断两者类型是否"),n("strong",[e._v("相同")]),e._v("。相同的话就是比大小了")])]),e._v(" "),n("li",[n("p",[e._v("类型不相同的话，那么就会进行类型转换")])]),e._v(" "),n("li",[n("p",[e._v("会先判断是否在对比 "),n("code",[e._v("null")]),e._v(" 和 "),n("code",[e._v("undefined")]),e._v("，是的话就会返回 "),n("code",[e._v("true")])])]),e._v(" "),n("li",[n("p",[e._v("判断两者类型是否为 "),n("code",[e._v("string")]),e._v(" 和 "),n("code",[e._v("number")]),e._v("，是的话就会将字符串转换为 "),n("code",[e._v("number")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1 == '1'\n      ↓\n1 ==  1\n\n")])])])]),e._v(" "),n("li",[n("p",[e._v("判断其中一方是否为 "),n("code",[e._v("boolean")]),e._v("，是的话就会把 "),n("code",[e._v("boolean")]),e._v(" 转为 "),n("code",[e._v("number")]),e._v(" 再进行判断")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("'1' == true\n        ↓\n'1' ==  1\n        ↓\n 1  ==  1\n\n")])])])]),e._v(" "),n("li",[n("p",[e._v("判断其中一方是否为 "),n("code",[e._v("object")]),e._v(" 且另一方为 "),n("code",[e._v("string")]),e._v("、"),n("code",[e._v("number")]),e._v(" 或者 "),n("code",[e._v("symbol")]),e._v("，是的话就会把 "),n("code",[e._v("object")]),e._v(" 转为原始类型再进行判断")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("'1' == { name: 'yck' }\n        ↓\n'1' == '[object Object]'\n\n")])])])])]),e._v(" "),n("blockquote",[n("p",[e._v("思考题：看完了上面的步骤，对于 [] == ![] 你是否能正确写出答案呢？")])]),e._v(" "),n("p",[e._v("如果你觉得记忆步骤太麻烦的话，我还提供了流程图供大家使用：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/19/167c4a2627fe55f1?w=1005&h=426&f=png&s=38534",alt:""}})]),e._v(" "),n("p",[e._v("当然了，这个流程图并没有将所有的情况都列举出来，我这里只将常用到的情况列举了，如果你想了解更多的内容可以参考 "),n("a",{attrs:{href:"https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("标准文档"),n("OutboundLink")],1),e._v("。")]),e._v(" "),n("p",[e._v("对于 "),n("code",[e._v("===")]),e._v(" 来说就简单多了，就是判断两者类型和值是否相同。")]),e._v(" "),n("h2",{attrs:{id:"闭包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[e._v("#")]),e._v(" 闭包")]),e._v(" "),n("blockquote",[n("p",[e._v("涉及面试题：什么是闭包？")])]),e._v(" "),n("p",[e._v("闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function A() {\n  let a = 1\n  window.B = function () {\n      console.log(a)\n  }\n}\nA()\nB() // 1\n\n")])])]),n("p",[e._v("很多人对于闭包的解释可能是函数嵌套了函数，然后返回一个函数。其实这个解释是不完整的，就比如我上面这个例子就可以反驳这个观点。")]),e._v(" "),n("p",[e._v("在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。")]),e._v(" "),n("blockquote",[n("p",[e._v("经典面试题，循环中使用闭包解决 `var` 定义函数的问题")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("for (var i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}\n\n")])])]),n("p",[e._v("首先因为 "),n("code",[e._v("setTimeout")]),e._v(" 是个异步函数，所以会先把循环全部执行完毕，这时候 "),n("code",[e._v("i")]),e._v(" 就是 6 了，所以会输出一堆 6。")]),e._v(" "),n("p",[e._v("解决办法有三种，第一种是使用闭包的方式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("for (var i = 1; i <= 5; i++) {\n  ;(function(j) {\n    setTimeout(function timer() {\n      console.log(j)\n    }, j * 1000)\n  })(i)\n}\n\n")])])]),n("p",[e._v("在上述代码中，我们首先使用了立即执行函数将 "),n("code",[e._v("i")]),e._v(" 传入函数内部，这个时候值就被固定在了参数 "),n("code",[e._v("j")]),e._v(" 上面不会改变，当下次执行 "),n("code",[e._v("timer")]),e._v(" 这个闭包的时候，就可以使用外部函数的变量 "),n("code",[e._v("j")]),e._v("，从而达到目的。")]),e._v(" "),n("p",[e._v("第二种就是使用 "),n("code",[e._v("setTimeout")]),e._v(" 的第三个参数，这个参数会被当成 "),n("code",[e._v("timer")]),e._v(" 函数的参数传入。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("for (var i = 1; i <= 5; i++) {\n  setTimeout(\n    function timer(j) {\n      console.log(j)\n    },\n    i * 1000,\n    i\n  )\n}\n\n")])])]),n("p",[e._v("第三种就是使用 "),n("code",[e._v("let")]),e._v(" 定义 "),n("code",[e._v("i")]),e._v(" 了来解决问题了，这个也是最为推荐的方式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("for (let i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}\n\n")])])]),n("h2",{attrs:{id:"深浅拷贝"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#深浅拷贝"}},[e._v("#")]),e._v(" 深浅拷贝")]),e._v(" "),n("blockquote",[n("p",[e._v("涉及面试题：什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？")])]),e._v(" "),n("p",[e._v("在上一章节中，我们了解了对象类型在赋值的过程中其实是复制了地址，从而会导致改变了一方其他也都被改变的情况。通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个情况。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let a = {\n  age: 1\n}\nlet b = a\na.age = 2\nconsole.log(b.age) // 2\n\n")])])]),n("h3",{attrs:{id:"浅拷贝"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝"}},[e._v("#")]),e._v(" 浅拷贝")]),e._v(" "),n("p",[e._v("首先可以通过 "),n("code",[e._v("Object.assign")]),e._v(" 来解决这个问题，很多人认为这个函数是用来深拷贝的。其实并不是，"),n("code",[e._v("Object.assign")]),e._v(" 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let a = {\n  age: 1\n}\nlet b = Object.assign({}, a)\na.age = 2\nconsole.log(b.age) // 1\n\n")])])]),n("p",[e._v("另外我们还可以通过展开运算符 "),n("code",[e._v("...")]),e._v(" 来实现浅拷贝")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let a = {\n  age: 1\n}\nlet b = { ...a }\na.age = 2\nconsole.log(b.age) // 1\n\n")])])]),n("p",[e._v("通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用到深拷贝了")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let a = {\n  age: 1,\n  jobs: {\n    first: 'FE'\n  }\n}\nlet b = { ...a }\na.jobs.first = 'native'\nconsole.log(b.jobs.first) // native\n\n")])])]),n("p",[e._v("浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。")]),e._v(" "),n("h3",{attrs:{id:"深拷贝"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝"}},[e._v("#")]),e._v(" 深拷贝")]),e._v(" "),n("p",[e._v("这个问题通常可以通过 "),n("code",[e._v("JSON.parse(JSON.stringify(object))")]),e._v(" 来解决。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let a = {\n  age: 1,\n  jobs: {\n    first: 'FE'\n  }\n}\nlet b = JSON.parse(JSON.stringify(a))\na.jobs.first = 'native'\nconsole.log(b.jobs.first) // FE\n\n")])])]),n("p",[e._v("但是该方法也是有局限性的：")]),e._v(" "),n("ul",[n("li",[e._v("会忽略 "),n("code",[e._v("undefined")])]),e._v(" "),n("li",[e._v("会忽略 "),n("code",[e._v("symbol")])]),e._v(" "),n("li",[e._v("不能序列化函数")]),e._v(" "),n("li",[e._v("不能解决循环引用的对象")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let obj = {\n  a: 1,\n  b: {\n    c: 2,\n    d: 3,\n  },\n}\nobj.c = obj.b\nobj.e = obj.a\nobj.b.c = obj.c\nobj.b.d = obj.b\nobj.b.e = obj.b.c\nlet newObj = JSON.parse(JSON.stringify(obj))\nconsole.log(newObj)\n\n")])])]),n("p",[e._v("如果你有这么一个循环引用对象，你会发现并不能通过该方法实现深拷贝")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/3/28/1626b1ec2d3f9e41?w=840&h=100&f=png&s=30123",alt:""}})]),e._v(" "),n("p",[e._v("在遇到函数、 "),n("code",[e._v("undefined")]),e._v(" 或者 "),n("code",[e._v("symbol")]),e._v(" 的时候，该对象也不能正常的序列化")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let a = {\n  age: undefined,\n  sex: Symbol('male'),\n  jobs: function() {},\n  name: 'yck'\n}\nlet b = JSON.parse(JSON.stringify(a))\nconsole.log(b) // {name: \"yck\"}\n\n")])])]),n("p",[e._v("你会发现在上述情况中，该方法会忽略掉函数和 "),n("code",[e._v("undefined")]),e._v(" 。")]),e._v(" "),n("p",[e._v("但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题。")]),e._v(" "),n("p",[e._v("如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 "),n("code",[e._v("MessageChannel")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function structuralClone(obj) {\n  return new Promise(resolve => {\n    const { port1, port2 } = new MessageChannel()\n    port2.onmessage = ev => resolve(ev.data)\n    port1.postMessage(obj)\n  })\n}\n\nvar obj = {\n  a: 1,\n  b: {\n    c: 2\n  }\n}\n\nobj.b.d = obj.b\n\n// 注意该方法是异步的\n// 可以处理 undefined 和循环引用对象\nconst test = async () => {\n  const clone = await structuralClone(obj)\n  console.log(clone)\n}\ntest()\n\n")])])]),n("p",[e._v("当然你可能想自己来实现一个深拷贝，但是其实实现一个深拷贝是很困难的，需要我们考虑好多种边界情况，比如原型链如何处理、DOM 如何处理等等，所以这里我们实现的深拷贝只是简易版，并且我其实更推荐使用 "),n("a",{attrs:{href:"https://lodash.com/docs#cloneDeep",target:"_blank",rel:"noopener noreferrer"}},[e._v("lodash 的深拷贝函数"),n("OutboundLink")],1),e._v("。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function deepClone(obj) {\n  function isObject(o) {\n    return (typeof o === 'object' || typeof o === 'function') && o !== null\n  }\n\n  if (!isObject(obj)) {\n    throw new Error('非对象')\n  }\n\n  let isArray = Array.isArray(obj)\n  let newObj = isArray ? [...obj] : { ...obj }\n  Reflect.ownKeys(newObj).forEach(key => {\n    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]\n  })\n\n  return newObj\n}\n\nlet obj = {\n  a: [1, 2, 3],\n  b: {\n    c: 2,\n    d: 3\n  }\n}\nlet newObj = deepClone(obj)\nnewObj.b.c = 1\nconsole.log(obj.b.c) // 2\n\n")])])]),n("h2",{attrs:{id:"原型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[e._v("#")]),e._v(" 原型")]),e._v(" "),n("blockquote",[n("p",[e._v("涉及面试题：如何理解原型？如何理解原型链？")])]),e._v(" "),n("p",[e._v("当我们创建一个对象时 "),n("code",[e._v("let obj = { age: 25 }")]),e._v("，我们可以发现能使用很多种函数，但是我们明明没有定义过它们，对于这种情况你是否有过疑惑？")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/16/1671d15f45fcedea?w=245****&h=73&f=png&s=8860",alt:""}})]),e._v(" "),n("p",[e._v("当我们在浏览器中打印 "),n("code",[e._v("obj")]),e._v(" 时你会发现，在 "),n("code",[e._v("obj")]),e._v(" 上居然还有一个 "),n("code",[e._v("__proto__")]),e._v(" 属性，那么看来之前的疑问就和这个属性有关系了。")]),e._v(" "),n("p",[e._v("其实每个 JS 对象都有 "),n("code",[e._v("__proto__")]),e._v(" 属性，这个属性指向了原型。这个属性在现在来说已经不推荐直接去使用它了，这只是浏览器在早期为了让我们访问到内部属性 "),n("code",[e._v("[[prototype]]")]),e._v(" 来实现的一个东西。")]),e._v(" "),n("p",[e._v("讲到这里好像还是没有弄明白什么是原型，接下来让我们再看看 "),n("code",[e._v("__proto__")]),e._v(" 里面有什么吧。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/16/1671d2c5a6bcccc4?w=383&h=271&f=png&s=41376",alt:""}})]),e._v(" "),n("p",[e._v("看到这里你应该明白了，原型也是一个对象，并且这个对象中包含了很多函数，所以我们可以得出一个结论：对于 "),n("code",[e._v("obj")]),e._v(" 来说，可以通过 "),n("code",[e._v("__proto__")]),e._v(" 找到一个原型对象，在该对象中定义了很多函数让我们来使用。")]),e._v(" "),n("p",[e._v("在上面的图中我们还可以发现一个 "),n("code",[e._v("constructor")]),e._v(" 属性，也就是构造函数")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/16/1671d329ec98ec0b?w=581&h=404&f=png&s=82731",alt:""}})]),e._v(" "),n("p",[e._v("打开 "),n("code",[e._v("constructor")]),e._v(" 属性我们又可以发现其中还有一个 "),n("code",[e._v("prototype")]),e._v(" 属性，并且这个属性对应的值和先前我们在 "),n("code",[e._v("__proto__")]),e._v(" 中看到的一模一样。所以我们又可以得出一个结论：原型的 "),n("code",[e._v("constructor")]),e._v(" 属性指向构造函数，构造函数又通过 "),n("code",[e._v("prototype")]),e._v(" 属性指回原型，但是并不是所有函数都具有这个属性，"),n("code",[e._v("Function.prototype.bind()")]),e._v(" 就没有这个属性。")]),e._v(" "),n("p",[e._v("其实原型就是那么简单，接下来我们再来看一张图，相信这张图能让你彻底明白原型和原型链")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/16/1671d387e4189ec8?w=618&h=781&f=png&s=266099",alt:""}})]),e._v(" "),n("p",[e._v("看完这张图，我再来解释下什么是原型链吧。其实原型链就是多个对象通过 "),n("code",[e._v("__proto__")]),e._v(" 的方式连接了起来。为什么 "),n("code",[e._v("obj")]),e._v(" 可以访问到 "),n("code",[e._v("valueOf")]),e._v(" 函数，就是因为 "),n("code",[e._v("obj")]),e._v(" 通过原型链找到了 "),n("code",[e._v("valueOf")]),e._v(" 函数。")]),e._v(" "),n("p",[e._v("对于这一小节的知识点，总结起来就是以下几点：")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("Object")]),e._v(" 是所有对象的爸爸，所有对象都可以通过 "),n("code",[e._v("__proto__")]),e._v(" 找到它")]),e._v(" "),n("li",[n("code",[e._v("Function")]),e._v(" 是所有函数的爸爸，所有函数都可以通过 "),n("code",[e._v("__proto__")]),e._v(" 找到它")]),e._v(" "),n("li",[e._v("函数的 "),n("code",[e._v("prototype")]),e._v(" 是一个对象")]),e._v(" "),n("li",[e._v("对象的 "),n("code",[e._v("__proto__")]),e._v(" 属性指向原型， "),n("code",[e._v("__proto__")]),e._v(" 将对象和原型连接起来组成了原型链")])])])}),[],!1,null,null,null);t.default=a.exports}}]);